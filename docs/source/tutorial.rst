pyKML Tutorial
==============

Constructing KML from scratch
-----------------------------

The pyKML library can be used to construct KML documents, using the 
:ref:`pykml-factory` module:

.. ipython::
    
    In [11]: from pykml.factory import KML_ElementMaker as KML
    
    In [12]: name_object = KML.name("Hello World!")

If you are creating KML documents that utilize elements that are not part
of the default KML namespace, you will want to create factory objects for
each namespace.  For example, the following creates factory objects for the
ATOM and Google Extensions namespace:

.. ipython::

    In [13]: from pykml.factory import ATOM_ElementMaker as ATOM

    In [14]: from pykml.factory import GX_ElementMaker as GX


Documents with nested KML tags can be created by nesting the creation
of Python objects:

.. ipython::
    
    In [16]: pm1 = KML.Placemark(
       ....:         KML.name("Hello World!"),
       ....:         KML.Point(
       ....:           KML.coordinates("-64.5253,18.4607")
       ....:         )
       ....:       )

Once a pyKML object element has been created, a string representation can be 
generated by using the `.tostring()` method:

.. ipython::
    
    In [21]: from lxml import etree
    
    @doctest
    In [22]: etree.tostring(pm1)
    Out[22]: '<Placemark xmlns:gx="http://www.google.com/kml/ext/2.2" xmlns:atom="http://www.w3.org/2005/Atom" xmlns="http://www.opengis.net/kml/2.2"><name>Hello World!</name><Point><coordinates>-64.5253,18.4607</coordinates></Point></Placemark>'

    # use the pretty_print option if you want something more readable
    In [23]: print etree.tostring(pm1, pretty_print=True)

pyKML creates Python objects, which  can be passed around and 
later aggregated.  The following creates a second placemark object, and then 
groups the two placemarks together in a folder.

.. ipython::
    
    In [31]: pm2 = KML.Placemark(
       ....:         KML.name("A second placemark!"),
       ....:         KML.Point(
       ....:           KML.coordinates("-64.5358,18.4486")
       ....:         )
       ....:       )
    
    In [32]: fld = KML.Folder(pm1,pm2)
    
    In [33]: print etree.tostring(fld, pretty_print=True)

Objects representing KML elements can also be appended into objects that have
already been created.
For example, the following appends yet another placemark to the folder.

.. ipython::
    
    In [41]: pm3=KML.Placemark(KML.name("A third placemark!"))
    
    In [42]: fld.append(pm3)
    
    In [43]: print etree.tostring(fld, pretty_print=True)

Similarly, you can remove elements from an existing object. The following removes the second of three placemarks from the folder:

.. ipython::
    
    In [51]: fld.remove(pm2)
    
    In [52]: print etree.tostring(fld, pretty_print=True)

Once you have a KML document, you can access elements using object attributes:

.. ipython::

    In [55]: print fld.Placemark.name.text

This type of attribute-based access is provided by the `lxml` packages's
`objectify API`. pyKML users are encouraged to familiarize themselves with the 
`objectify API documentation`_ on the lxml website, because pyKML inherits this
functionality.

.. _objectify API documentation: http://lxml.de/objectify.html


Parsing existing KML documents
------------------------------

Sometimes instead of building a KML document from scratch, you may want to 
modify an existing KML document.  For this case, pyKML's parsing capabilities
are useful.  pyKML can parse information from a variety of sources, including
strings, local files, and remote URLs.  

The most straightforward is parsing from a string...

.. ipython::

    In [61]: from pykml import parser

    In [62]: kml_str = '<kml xmlns="http://www.opengis.net/kml/2.2">' \
       ....:             '<Document>' \
       ....:               '<Folder>' \
       ....:                 '<name>sample folder</name>' \
       ....:               '</Folder>' \
       ....:             '</Document>' \
       ....:           '</kml>'

    In [63]: root = parser.fromstring(kml_str)

    In [64]: print root.Document.Folder.name.text

You can also parse a local file...

.. ipython::

    In [71]: from os import path
    
    In [72]: kml_file = path.join( \
       ....:     '../src/pykml/test', \
       ....:     'testfiles/google_kml_developers_guide', \
       ....:     'complete_tour_example.kml')
    
    In [73]: with open(kml_file) as f:

    In [74]:     doc = parser.parse(f)
    
    In [75]: 

... or a remote URL...

.. ipython::

    In [80]: import urllib2
    
    In [81]: url = 'http://code.google.com/apis/kml/documentation/KML_Samples.kml'

    In [82]: fileobject = urllib2.urlopen(url)
        
    In [83]: root = parser.parse(fileobject).getroot()
    
    In [84]: print root.Document.name

Validation of KML documents
---------------------------

The KML documents that you create can be validated against XML Schema documents,
which define the rules of which elements are acceptible and what ordering can 
be used.  The OGC KML schema and the Google Extension schemas are included with pyKML.

To validate your KML document, first create instances of the schemas:

.. ipython::

    In [100]: from pykml.parser import Schema

    In [101]: schema_ogc = Schema("ogckml22.xsd")

    In [102]: schema_gx = Schema("kml22gx.xsd")

Then use the schemas to validate your KML objects, using the `.validate()` 
method.  The following lines of code create a small KML document that
includes an element from the Google Extension namespace (`<gx_Tour>`) so 
the document does not validate against the basic OGC KML schema, but does
validate agains the Google Extensions schema. 

.. ipython::

    In [110]: doc = KML.kml(GX.Tour())

    In [111]: schema_ogc.validate(doc)
    
    In [112]: schema_gx.validate(doc)

The `.validate()` method only returns True or False.  For invalid documents, 
it is often useful to obtain details of why the document is invalid
using the `.assertValid()` method:
    
.. ipython::

    In [113]: schema_ogc.assertValid(doc)

You can also validate while parsing by including a schema object as a parameter.
The following triggers an error because <eggplant> is not a valid OGC KML element:

.. ipython::

    In [62]: bad_kml_str = '<kml xmlns="http://www.opengis.net/kml/2.2">' \
       ....:             '<Document>' \
       ....:               '<Folder>' \
       ....:                 '<eggplant/>' \
       ....:               '</Folder>' \
       ....:             '</Document>' \
       ....:           '</kml>'

    In [63]: root = parser.fromstring(bad_kml_str, schema_ogc)



Setting the Number of Decimal Places
------------------------------------
Many KML files, especially those authored by Google Earth, contain coordinate
information with more decimal places that often is necessary.  
The `set_max_decimal_places()` function addresses this, but allowing a user
to reduce the number of decimal places used.




Building pyKML Python Scripts
-----------------------------
While using Python and pyKML allows you use leverage programming to create
customized KML files, writing the initial pyKML code can be tedious.
To help with this, pyKML provides the verbosely named
`.write_python_script_for_kml_document()` function which will produce
a Python script that can serve as a starting point for further customization.

.. ipython::

    In [10]: from pykml.factory import write_python_script_for_kml_document

    In [11]: url = 'http://code.google.com/apis/kml/documentation/kmlfiles/altitudemode_reference.kml'

    In [12]: fileobject = urllib2.urlopen(url)
        
    In [13]: doc = parser.parse(fileobject).getroot()

    In [14]: script = write_python_script_for_kml_document(doc)

    In [15]: print script
